[
  {
    "title": "End-to-End DevOps Automation",
    "problem": "I designed and implemented a complete, end-to-end DevOps workflow to automatically build, test, deploy, and monitor a web application. The project leverages a suite of industry-standard tools to demonstrate a full software delivery lifecycle. A git push to the main branch automatically triggers the entire pipeline, resulting in a new version of the application being deployed and monitored in real-time without any manual intervention.",
    "solution": "The project integrates a suite of industry-standard tools to create a seamless software delivery lifecycle: <ul><li><strong>GitLab:</strong> Used for version control and as the trigger for the CI/CD pipeline.</li><li><strong>Jenkins:</strong> Acts as the automation server to run the build, test, and deployment jobs.</li><li><strong>Docker:</strong> Containerizes the application to ensure consistency across all environments.</li><li><strong>Terraform:</strong> Manages cloud resources as code for repeatable and automated infrastructure provisioning on AWS.</li><li><strong>Ansible:</strong> Handles configuration management to set up servers and deploy the application.</li><li><strong>Prometheus:</strong> Scrapes real-time metrics from the application and infrastructure for monitoring.</li><li><strong>Grafana:</strong> Visualizes the data collected by Prometheus in a comprehensive dashboard for live monitoring and alerting.</li><li><strong>AWS:</strong> Serves as the cloud provider for hosting the entire infrastructure.</li></ul>",
    "outcome": "Through this project, I gained hands-on experience in: <ul><li>Automating a full CI/CD pipeline from code commit to production deployment.</li><li>Integrating multiple DevOps tools like GitLab, Jenkins, and Ansible to work together seamlessly.</li><li>Containerizing applications with Docker for portability and consistency.</li><li>Setting up a complete observability stack with Prometheus and Grafana to monitor application health.</li><li>Troubleshooting real-world issues related to networking, permissions, and system configurations in a cloud environment.</li></ul> <br> <strong>Links:</strong> <br> <a href='#' class='text-accent hover:underline'>View the Live Site</a> <br> <a href='#' class='text-accent hover:underline'>View the Live Dashboard</a>",
    "tech": ["GitLab", "Jenkins", "Docker", "Terraform", "Ansible", "Prometheus", "Grafana", "AWS"],
    "githubLink": "https://github.com/Shrisab/End-to-End-DevOps-Automation",
    "icons": ["devicon-gitlab-plain", "devicon-jenkins-plain", "devicon-docker-plain", "devicon-terraform-plain", "devicon-ansible-plain", "devicon-prometheus-original", "devicon-grafana-original", "devicon-amazonwebservices-original"],
    "visuals": [
      { "src": "assets/project/P1-1.png", "alt": "ec2-instance" },
      { "src": "assets/project/P1-2.png", "alt": "GitLab Pipeline" },
      { "src": "assets/project/P1-3.png", "alt": "App-deploy" },
      { "src": "assets/project/P1-4.png", "alt": "Prometheus" },
      { "src": "assets/project/P1-5.png", "alt": "aws" },
      { "src": "assets/project/P1-6.png", "alt": "Grafana Dashboard" }
    ]
  },
  {
    "title": "AWS-iac-platform-automation",
    "problem": "The primary goal of this project is to create a full-stack, API-driven framework for complete, end-to-end automation of cloud infrastructure on Amazon Web Services (AWS). The framework is designed to deploy and manage complex, multi-server environments with a single API call, handling every stage of the cloud deployment lifecycle.",
    "solution": "The project provides a solution that uses a combination of Terraform for infrastructure provisioning and Ansible for configuration management, all orchestrated through a set of Flask APIs. The system is designed for a seamless, automated workflow triggered by a single request: <ol style='margin-top: 10px; padding-left: 20px;'><li>1. A user sends a POST request to the Deployment API (trigger_deploy.py) with parameters defining the desired environment.</li><li>2. The API triggers the main deploy.sh script.</li><li>3. Terraform takes over, initializing the correct workspace and applying the infrastructure plan to provision all necessary AWS resources.</li><li>4. Once the infrastructure is up, a Python script (generate_inventory.py) runs to inspect the new resources and create a dynamic merged_inventory.json file for Ansible.</li><li>5. Ansible then executes its main playbook (main.yml) against the newly created inventory, performing all configuration tasks on the target instances.</li><li>6. The result is a fully configured, ready-to-use environment, which can then be managed and monitored using the other provided APIs.</li></ol>",
    "outcome": "The key outcomes of this project are: <ul style='margin-top: 10px; padding-left: 20px;'><li><strong>Infrastructure as Code (IaC):</strong> All AWS resources are defined programmatically using Terraform.</li><li><strong>API-Driven Operations:</strong> A set of Flask APIs serves as the primary control plane for all operations, from deployment to monitoring.</li><li><strong>Multi-Environment Management:</strong> The use of Terraform Workspaces enables the creation and management of isolated environments from the same codebase.</li><li><strong>Dynamic Inventory Generation:</strong> An Ansible inventory is automatically generated based on the resources provisioned by Terraform.</li><li><strong>Comprehensive Configuration Management:</strong> Ansible is used for a wide range of configuration tasks, including installing software, managing storage, and securely transferring files.</li></ul>",
    "tech": ["Terraform", "Ansible", "Python", "AWS", "Flask", "Bash", "Boto3", "Paramiko"],
    "githubLink": "https://github.com/Shrisab/aws-iac-platform-automation",
    "icons": ["devicon-ansible-plain", "devicon-terraform-plain", "devicon-python-plain", "devicon-amazonwebservices-original"]
  },
  {
    "title": "Automated SSL Certificate Management",
    "problem": "The primary goal of this project is to automate the renewal and management of SSL/TLS certificates using Let's Encrypt and Terraform. This automation simplifies the process of keeping a website's SSL certificates up-to-date and secure.",
    "solution": "The project provides a set of scripts that work together to achieve the goal of automated SSL certificate management. The key components of the solution are: <ol style='margin-top: 10px; padding-left: 20px;'><li><strong>Proactive Certificate Expiration Checks:</strong> A script named check-certificate-expiry.sh is used to check if an SSL certificate is already expired or if it will expire within the next 10 days.</li><li><strong>Automated Certificate Renewal:</strong> The new-renew.sh script automates the process of renewing SSL/TLS certificates with Let's Encrypt using DNS challenges.</li><li><strong>Terraform Integration for Infrastructure Management:</strong> The main script, start.sh, integrates with Terraform to automatically provision and de-provision the necessary infrastructure for certificate renewal.</li><li><strong>Scheduled Renewals with Cron:</strong> The new-renew.sh script adds a cron job to automatically run the renewal script every Sunday at midnight, ensuring regular checks without manual intervention.</li></ol>",
    "outcome": "The key outcomes of using this solution are: <ul style='margin-top: 10px; padding-left: 20px;'><li><strong>Fully Automated SSL/TLS Certificate Renewal:</strong> The entire process of checking for certificate expiration, renewing the certificate, and managing the necessary infrastructure is automated.</li><li><strong>Enhanced Security:</strong> By ensuring that SSL/TLS certificates are always up-to-date, the solution helps in maintaining the security of the website.</li><li><strong>Proactive Management:</strong> The system proactively checks for certificate expiration, preventing any downtime or security warnings due to expired certificates.</li><li><strong>Simplified Certificate Management:</strong> The solution simplifies what can be a complex and manual process of managing SSL/TLS certificates.</li></ul>",
    "tech": ["Let's Encrypt", "Terraform", "Bash", "Cron"],
    "githubLink": "https://github.com/Shrisab/Cert-Automate-SSL-TLS-Certificate-Management",
    "icons": ["devicon-bash-plain", "devicon-terraform-plain"]
  },
  {
    "title": "Ansible Playbook for AWS Server Provisioning",
    "problem": "The primary goal of using an Ansible playbook for AWS server provisioning is to automate the process of setting up and managing servers and other resources in the Amazon Web Services (AWS) cloud. This is a key practice in the world of Infrastructure as Code (IaC), where you manage your infrastructure using code or definition files rather than manual configuration. The aim is to make the process more efficient, repeatable, and less prone to human error.",
    "solution": "An Ansible playbook for AWS provisioning typically includes a series of tasks that define the desired state of your AWS infrastructure. Here's how it generally works: <ol style='margin-top: 10px; padding-left: 20px;'><li><strong>Playbook Structure:</strong> The solution is centered around one or more YAML files called 'playbooks.' These playbooks list a series of 'plays,' each containing 'tasks.'</li><li><strong>Authentication:</strong> The playbook needs to authenticate with your AWS account. This can be done by providing your AWS access and secret keys as environment variables, in a separate variables file, or by using AWS profiles.</li><li><strong>Provisioning Resources:</strong> The playbook uses Ansible's AWS modules to create and manage various AWS resources like EC2 instances, VPCs, and Security Groups.</li><li><strong>Dynamic Inventory:</strong> After provisioning new EC2 instances, you can use a dynamic inventory script to automatically add these new instances to Ansible's inventory for further configuration.</li><li><strong>Configuration:</strong> Once the infrastructure is provisioned, another play can target the new instances to install software, configure services, and deploy applications.</li><li><strong>Lifecycle Management:</strong> IaC with Ansible also includes the ability to destroy the infrastructure you've created.</li></ol>",
    "outcome": "By using an Ansible playbook for AWS server provisioning, you can achieve several key outcomes: <ul style='margin-top: 10px; padding-left: 20px;'><li><strong>Automation:</strong> The entire process of setting up your infrastructure is automated, saving time and reducing the risk of manual errors.</li><li><strong>Consistency:</strong> Your infrastructure will be provisioned in a consistent and repeatable manner every time the playbook is run.</li><li><strong>Scalability:</strong> You can easily scale your infrastructure up or down by changing a few variables in your playbook.</li><li><strong>Version Control:</strong> Since your infrastructure is defined in code, you can use version control systems like Git to track changes, collaborate, and roll back if needed.</li><li><strong>Agility:</strong> Automation allows you to quickly provision new environments for development, testing, or production.</li></ul>",
    "tech": ["Ansible", "YAML", "AWS", "Python", "Boto3", "AWS CLI", "Git", "Jinja2"],
    "githubLink": "https://github.com/Shrisab/Ansible",
    "icons": ["devicon-ansible-plain", "devicon-amazonwebservices-original"]
  },
  {
    "title": "Terraform Project for AWS Network Infrastructure",
    "problem": "Manually creating AWS networking infrastructure is complex and lacks version control, making it difficult to replicate or manage changes.",
    "solution": "I built a modular Terraform project to define the entire network stack (VPC, subnets, IGW, route tables) and deploy an EC2 instance as code.",
    "outcome": "Enabled version-controlled, repeatable, and easily manageable AWS infrastructure. New environments can now be created or destroyed in minutes.",
    "tech": ["Terraform", "AWS", "HCL"],
    "githubLink": "https://github.com/Shrisab/Terraform",
    "icons": ["devicon-terraform-plain", "devicon-amazonwebservices-original"]
  }
]